#!/usr/bin/env python3

import os, subprocess
import sys, argparse
import hashlib, json, re

class MalwareFinder():
    def __init__(self, volatility, cachedir, image, profile):
        self.volatility = volatility
        self.cachedir = cachedir
        self.image = image
        self.profile = profile

        if os.path.isfile(self.image + '.sha512sum'):
            self.hash = open(self.image + '.sha512sum', 'r').read().split()[0]
        else:
            print('Generating SHA512 checksum')
            h = hashlib.sha512()

            with open(self.image, 'rb') as f:
                for chunk in iter(lambda: f.read(65536), b''):
                    h.update(chunk)

            self.hash = h.hexdigest()

            open(self.image + '.sha512sum', 'w').write('%s  %s\n' % (self.hash, os.path.basename(self.image)))

    def _cache(self, name, data=None):
        path = '%s/%s.cache' % (self.cachedir, name)

        if data:
            open(path, 'w').write(data)
            return data
        else:
            if os.path.isfile(path):
                return open(path, 'r', encoding='utf-8').read()
            else:
                return None

    def _exec(self, args, _json=True):
        cmd = [ self.volatility, '--filename=' + os.path.abspath(self.image) ]

        if _json:
              cmd.append('--output=json')

        if self.profile:
            cmd.append('--profile=' + self.profile)

        cmd.extend(args)

        hash = hashlib.sha512(('%s_%s_%s_%s' % (self.hash, 'json' if _json else 'console', self.profile, ' '.join(args))).encode('utf-8')).hexdigest()
        cache = self._cache(hash)

        if not cache:
            print('Executing "%s"' % ' '.join(args))
            p = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            stdout, stderr = p.communicate()

            if p.returncode != 0:
                print(stderr)
                return None

            cache = self._cache(hash, stdout.decode('utf-8'))

        if _json:
            data = json.loads(cache)
            norm = []

            for row in data['rows']:
                norm.append(dict(zip(data['columns'], row)))

            return norm
        else:
            return cache

    def identify(self):
        if not self.profile:
            data = self.imageinfo()
            profiles = re.split('[, ]+', re.sub('\s*\([^)]*\)\s*', '', data[0]['Suggested Profile(s)']))
            # TODO check which profile actually works
            self.profile = profiles[0]

        return self.profile

    def printkey_autostart(self):
        return self._exec(['printkey', '-K', 'Software\\Microsoft\\Windows\\CurrentVersion\\Run'])

    def imageinfo(self):
        return self._exec(['imageinfo'])

    def pslist(self):
        return self._exec(['pslist'])

    def dlllist(self):
        return self._exec(['dlllist'])

    def evildll(self):
        for dll in self.dlllist():
            if not dll['Path'] in ['Error reading PEB for pid', ''] and not re.match('^[Cc]:\\\\(Program Files|[Ww]indows|WINDOWS)\\\\', dll['Path']):
                print(json.dumps(dll, indent=4))

    def psxview(self):
        return self._exec(['psxview', '--apply-rules'])

    def evilps(self):
        for ps in self.psxview():
            for key in ['thrdproc', 'csrss', 'pslist', 'deskthrd', 'session', 'pspcid', 'psscan']:
                if not ps[key] in ['True', 'Okay']:
                    print(json.dumps(ps, indent=4))
                    break

    def ldrmodules(self):
        return self._exec(['ldrmodules'])

    def malfind(self):
        return self._exec(['malfind'])

    def vadinfo(self):
        return self._exec(['vadinfo'])

    def apihooks(self):
        return self._exec(['apihooks'])

    def correlate(self):
        malfind = self.malfind()
        vadinfo = self.vadinfo()
        apihooks = self.apihooks()

        pids = []

        for mal in malfind:
            for vad in vadinfo:
                if mal['Address'] >= vad['Start'] and mal['Address'] <= vad['End']:
                    start = vad['Start']
                    end = vad['End']
                    break

            for hook in apihooks:
                if hook['HookAddress'] >= start and hook['HookAddress'] <= end:

                    if mal['Pid'] in pids:
                        break

                    pids.append(mal['Pid'])

                    print('cmd: %s\npid: %d' % (mal['Process'], mal['Pid']))
                    print(json.dumps(hook, indent=4))
                    #print(self._exec(['malfind', '-p', str(mal['Pid'])], False))
                    break

    def hollow(self):
        malfind = self.malfind()

        for mal in malfind:
            ldrmodules = self._exec(['ldrmodules', '-p', str(mal['Pid'])])

            for mod in ldrmodules:
                if mod['InLoad'] != 'True' and mod['InInit'] != 'True' and mod['InMem'] != 'True':
                    print(json.dumps(mod, indent=4))
                    break

if __name__ == '__main__':
    argparser = argparse.ArgumentParser()
    argparser.add_argument('-v', '--volatility', default='/home/y/bfh/malware/volatility_2.5.linux.standalone/volatility_2.5_linux_x64',
        help='Path to the volatility executable')
    argparser.add_argument('-c', '--cache', default='cache', help='Path to the caching directory')
    argparser.add_argument('-p', '--profile', default=None, help='Image\'s volatility profile')
    argparser.add_argument('image', type=str, help='Path to the image to analyze')

    options = argparser.parse_args(sys.argv[1:])
    mf = MalwareFinder(options.volatility, options.cache, options.image, profile=options.profile)

    print('SHA512 checksum: %s' % mf.hash)
    print('Profile: %s' % mf.identify())

    while True:
        cmd = input(os.path.splitext(os.path.basename(sys.argv[0]))[0] + '> ').strip()

        if cmd == 'quit':
            break
        elif cmd == '':
            continue
        elif cmd == 'help':
            print('Internal commands:')
            for m in [m for m in dir(mf) if m[0] != '_' and callable(getattr(mf, m))]:
                print('* %s' % m)
        elif cmd[0] == ':':
            func = getattr(mf, cmd[1:])
            if func:
                ret = func()
                if ret:
                    print(json.dumps(ret, indent=4))
            else:
                print('%s: method not found' % cmd[1:])
        else:
            print(mf._exec(re.split('\s+', cmd), False))
            #print('%s: command not found' % cmd)
