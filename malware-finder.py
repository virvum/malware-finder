#!/usr/bin/env python3

import os, platform, atexit, subprocess, threading, queue
import code, sys, argparse
import hashlib, json, re, operator
import time, configparser

__PROG_NAME__ = os.path.splitext(os.path.basename(sys.argv[0]))[0]

try:
    import readline
except ImportError:
    print('WARNING: readline module not found, deactivating history etc.')

try:
    import requests
except ImportError:
    print('WARNING: requests module not found, deactivating VirusTotal scanning')

try:
    from colorama import Fore, Style
    def red(s):     return Style.BRIGHT + Fore.RED + s + Style.RESET_ALL
    def green(s):   return Style.BRIGHT + Fore.GREEN + s + Style.RESET_ALL
    def blue(s):    return Style.BRIGHT + Fore.BLUE + s + Style.RESET_ALL
except ImportError:
    print('WARNING: colorama module not found, deactivating colors')
    def red(s):     return s
    def green(s):   return s
    def blue(s):    return s

def human_readable(num):
    for unit in ['B','KiB','MiB','GiB','TiB','PiB','EiB','ZiB']:
        if abs(num) < 1024.0:
            return (num, unit)
        num /= 1024.0
    return (num, 'YiB')

def which(cmd):
    fpath, fname = os.path.split(cmd)

    if fpath:
        if os.path.isfile(cmd) and os.access(cmd, os.X_OK):
            return cmd
    else:
        for path in os.environ['PATH'].split(os.pathsep):
            exe_file = os.path.join(path.strip('"'), cmd)

            if os.path.isfile(exe_file) and os.access(exe_file, os.X_OK):
                return exe_file

    return os.path.join('.', cmd)

def win32_get_appdata_path():
    import ctypes

    HANDLE = ctypes.c_void_p
    HWND = HANDLE
    INT = ctypes.c_int
    DWORD = ctypes.c_ulong

    CSIDL_APPDATA = 26
    MAX_PATH = 260
    SHGFP_TYPE_CURRENT = 0

    path = ctypes.create_unicode_buffer(MAX_PATH)

    hres = ctypes.windll.shell32.SHGetFolderPathW \
        ( HWND(0)
        , INT(CSIDL_APPDATA)
        , HANDLE(0)
        , DWORD(SHGFP_TYPE_CURRENT)
        , ctypes.byref(path)
        )

    if hres == 0:
        return path.value
    else:
        return None

class HistoryConsole(code.InteractiveConsole):
    def __init__(self, hash, locals=None, filename='<console>', completer=None):
        path = os.path.join(os.path.expanduser('~'), '.%s' % __PROG_NAME__)

        if not os.path.isdir(path):
            print('Creating directory "%s"' % path)
            os.mkdir(path)

        histfile = os.path.join(path, 'history_%s' % hash)
        code.InteractiveConsole.__init__(self, locals, filename)

        if completer:
            readline.parse_and_bind('tab: complete')
            readline.set_completer(completer)

        if hasattr(readline, 'read_history_file'):
            if os.path.isfile(histfile):
                print('Reading history from "%s"' % histfile)
                readline.read_history_file(histfile)

            atexit.register(self.save_history, histfile)

    def save_history(self, histfile):
        print('Writing history to "%s"' % histfile)
        readline.write_history_file(histfile)

class VirusTotal():
    def __init__(self, api_key, nworkers=4):
        self.api_key = api_key
        self.nworkers = nworkers
        self.queue = queue.Queue()
        self.threads = []

    def add(self, file):
        self.queue.put(file, callback)

    def worker(self):
        while True:
            try:
                file, callback = self.queue.get()
            except TypeError:
                return

            callback(file, self.scan(file))

    def stop(self):
        for i in range(self.nworkers):
            self.queue.put(None)

        for t in self.threads:
            t.join()

    def scan(self, file, upload_callback=None, loop_callback=None):
        if not self.api_key:
            print(red('No VirusTotal API key set.'))
            return None

        res = requests.post('https://www.virustotal.com/vtapi/v2/file/scan'
            , files={ 'file': ( os.path.basename(file), open(file, 'rb')) }
            , params={ 'apikey': self.api_key }
            ).json()

        resource = res['resource']
        t = 2

        if upload_callback:
            upload_callback()

        while True:
            res = requests.get('https://www.virustotal.com/vtapi/v2/file/report'
                , params={ 'apikey': self.api_key, 'resource': resource }
                )

            if loop_callback:
                loop_callback()

            try:
                data = res.json()
            except:
                time.sleep(t)
                continue

            if 'scans' in data:
                break

            time.sleep(t)
            t += 2

        return data

class MalwareFinder():
    def __init__(self, volatility, cachedir, dumpdir, image, profile, vt_api_key, vt_workers):
        self.volatility = volatility
        self.cachedir = cachedir
        self.dumpdir = dumpdir
        self.image = image
        self.profile = profile
        self._vt = VirusTotal(vt_api_key, vt_workers)

        if os.path.isfile(self.image + '.sha512sum'):
            self.hash = open(self.image + '.sha512sum', 'r').read().split()[0]
        else:
            print('Generating SHA512 checksum of "%s"' % self.image)
            hash = hashlib.sha512()

            with open(self.image, 'rb') as f:
                for chunk in iter(lambda: f.read(65536), b''):
                    hash.update(chunk)

            self.hash = hash.hexdigest()
            open(self.image + '.sha512sum', 'w').write('%s  %s\n' % (self.hash, os.path.basename(self.image)))

        self.identify()

    def _cache(self, name, data=None):
        path = os.path.join(self.cachedir, '%s.cache' % name)

        if data:
            open(path, 'w').write(data)
            return data
        else:
            if os.path.isfile(path):
                return open(path, 'r', encoding='utf-8').read()
            else:
                return None

    def _exec(self, args, _json=True, _cache=True, showexec=True):
        cmd = [ self.volatility, '--filename=' + os.path.abspath(self.image) ]

        if _json:
              cmd.append('--output=json')

        if self.profile:
            cmd.append('--profile=' + self.profile)

        cmd.extend(args)

        if _cache:
            hash = hashlib.sha512(('%s_%s_%s_%s' % (self.hash, 'json' if _json else 'console', self.profile, ' '.join(args))).encode('utf-8')).hexdigest()
            cache = self._cache(hash)
        else:
            cache = None

        if not cache:
            if showexec:
                print('Executing "%s"' % ' '.join(args))

            p = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            stdout, stderr = p.communicate()

            if p.returncode != 0:
                print(red(stderr.decode('utf-8').strip()))
                return None

            cache = self._cache(hash, stdout.decode('utf-8')) if _cache else stdout.decode('utf-8')

        if _json:
            data = json.loads(cache)
            norm = []

            for row in data['rows']:
                norm.append(dict(zip(data['columns'], row)))

            return norm
        else:
            return cache

    def identify(self, _=None):
        if not self.profile:
            data = self._exec(['imageinfo'])
            profiles = re.split('[, ]+', re.sub('\s*\([^)]*\)\s*', '', data[0]['Suggested Profile(s)']))

            for profile in profiles:
                print('Testing profile "%s" using "pslist"' % profile)
                self.profile = profile
                if self._exec(['pslist'], showexec=False):
                    break

        return self.profile

    def _dlllist(self, _=None):
        return self._exec(['dlllist'])

    def _psxview(self, _=None):
        return self._exec(['psxview', '--apply-rules'])

    def _ldrmodules(self, _=None):
        return self._exec(['ldrmodules'])

    def _malfind(self, _=None):
        return self._exec(['malfind'])

    def _vadinfo(self, _=None):
        return self._exec(['vadinfo'])

    def _apihooks(self, _=None):
        return self._exec(['apihooks'])

    def strings(self, _=[]):
        argparser = argparse.ArgumentParser(prog=sys._getframe().f_code.co_name, description='Scan process or DDL for strings')
        argparser.add_argument('-p', '--pid', type=int, required=True, help='PID of process to scan')
        argparser.add_argument('-a', '--addr', type=str, help='Base address')
        argparser.add_argument('-l', '--minlen', type=int, default=8, help='Minimal length of matched strings')

        try:
            opts = argparser.parse_args(args)
        except SystemExit:
            return

        if opts.addr:
            res = self._exec(['dlldump', '--dump-dir=%s' % self.dumpdir, '--pid=%d' % opts.pid, '--base=%s' % opts.addr], _cache=False)
        else:
            res = self._exec(['procdump', '--dump-dir=%s' % self.dumpdir, '--pid=%d' % opts.pid], _cache=False)

        file = os.path.join(self.dumpdir, res[0]['Result'][4:])

        if not os.path.isfile(file):
            print(red(res[0]['Result']))
            return

        pattern = re.compile(bytes('[A-Za-z0-9/\-:.,_$%%\'"()[\]<> ]{%d,}' % opts.minlen, 'utf-8'))

        for p in pattern.findall(open(file, 'rb').read()):
            print(p.decode('utf-8'))

    def autostart(self, _=None):
        entries = []

        for k in [ 'Software\\Microsoft\\Windows\\CurrentVersion\\Run'
                 , 'Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce'
                 , 'Software\\Microsoft\\Windows\\CurrentVersion\\RunServices'
                 , 'Software\\Microsoft\\Windows\\CurrentVersion\\RunServicesOnce'
                 , 'Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\Userinit'
                 ]:
            l = self._exec(['printkey', '--key=%s' % k])

            if l:
                entries.extend(l)

        for e in entries:
            print('%-8s %-20s %s' % (e['KeyName'], e['ValName'], e['ValData']))

    def fishydllpath(self, args=[]):
        try:
            argparse.ArgumentParser(prog=sys._getframe().f_code.co_name
                , description='Find DLLs whose location on the filesystem is fishy (e.g. not under C:\\Windows\\)').parse_args(args)
        except SystemExit:
            return

        dlllist = self._dlllist()
        malfind = self._malfind()

        print('%10s %10s %8s %6s %s %s' % ('Base', 'LoadCount', 'Size', 'PID', 'Malfind', 'Path'))
        for dll in dlllist:
            if not re.match('^[Cc]:\\\\(Program Files|[Ww]indows|WINDOWS)\\\\', dll['Path']):
                match = any(dll['Base'] == mal['Address'] for mal in malfind)
                print('0x%08x %10d %8d %6d %s %s' %
                    ( dll['Base'], dll['LoadCount'], dll['Size'], dll['Pid']
                    , red('  MATCH') if match else '      -', dll['Path']))

    def evilhooks(self, args=[]):
        argparser = argparse.ArgumentParser(prog=sys._getframe().f_code.co_name, description='Find regions marked by malfind which are hook targets')
        argparser.add_argument('-p', '--pid', type=int, help='Analyze hooks for a single process')
        argparser.add_argument('-v', '--verbose', action='store_true', help='Show more stuff')

        try:
            opts = argparser.parse_args(args)
        except SystemExit:
            return

        malfind = self._malfind()
        apihooks = self._apihooks()

        if opts.pid:
            if not opts.verbose:
                print(red('only showing hook targets which are marked by malfind or hooks which have an unknown hooking module'))

            print('PID: %d' % opts.pid)
            print('%-11s %-20s %-20s %-30s %11s %7s %s' % ('HookMode', 'HookingModule', 'VictimModule', 'HookType', 'HookAddress', 'Malfind', 'Function'))

            for hook in apihooks:
                if hook['PID'] == opts.pid:
                    match = any(mal['Address'] == hook['HookAddress'] for mal in malfind)
                    if match or hook['HookingModule'] == '<unknown>' or opts.verbose:
                        print('%-11s %-20s %-20s %-30s 0x%09x %s %s' %
                            ( hook['HookMode'], hook['HookingModule'], hook['VictimModule'], hook['HookType'], hook['HookAddress']
                            , red('  MATCH') if match else '      -', hook['Function']
                            ))
        else:
            vadinfo = self._vadinfo()

            if not opts.verbose:
                print(red('only showing regions which are marked by malfind and used by hooks'))

            print('%-10s %-20s %5s %6s' % ('Address', 'Process', 'PID', 'Hooked'))

            for mal in malfind:
                start, end = None, None
                for vad in vadinfo:
                    if mal['Address'] >= vad['Start'] and mal['Address'] <= vad['End']:
                        start = vad['Start']
                        end = vad['End']
                        break

                if not start or not end:
                    print(red('VAD region for PID %d Base 0x%x not found') % (mal['Pid'], mal['Address']))
                    continue

                hooked = sum(hook['HookAddress'] >= start and hook['HookAddress'] <= end for hook in apihooks)

                if hooked or opts.verbose:
                    print('0x%08x %-20s %5d %6d' % (mal['Address'], mal['Process'], mal['Pid'], hooked))

    def evilps(self, args=[]):
        argparser = argparse.ArgumentParser(prog=sys._getframe().f_code.co_name, description='Find processes via psxview which are unlinked somehow')
        argparser.add_argument('-v', '--verbose', action='store_true', help='Also show processes which are not marked by malfind')

        try:
            opts = argparser.parse_args(args)
        except SystemExit:
            return

        psxview = self._psxview()
        malfind = self._malfind()
        vadinfo = self._vadinfo()

        if not opts.verbose:
            print(red('only showing processes marked by malfind'))

        print('%-10s %-30s %5s %-8s %-8s %-8s %-8s %-8s %-8s %-8s %7s %s'
            % ('Address', 'Name', 'PID', 'pslist', 'psscan', 'thrdproc', 'pspcid', 'csrss', 'session', 'deskthrd', 'Malfind', 'ExitTime'))

        for ps in psxview:
            if not all(ps[k] in ['True', 'Okay'] for k in ['thrdproc', 'csrss', 'pslist', 'deskthrd', 'session', 'pspcid', 'psscan']):
                # Locate the memory region of the process
                start, end = None, None
                for vad in vadinfo:
                    if ps['Offset(P)'] >= vad['Start'] and ps['Offset(P)'] <= vad['End']:
                        start = vad['Start']
                        end = vad['End']
                        break

                matches = -1

                if start and end:
                    # Let's see if any region of this process is listed in malfind
                    matches = sum(mal['Address'] >= start and mal['Address'] <= end for mal in malfind) \
                        if start and end else 0

                if opts.verbose or matches > 0:
                    print('0x%-8x %-30s %5d %-8s %-8s %-8s %-8s %-8s %-8s %-8s %7s %s' %
                        ( ps['Offset(P)'], ps['Name'], ps['PID'], ps['pslist'], ps['psscan']
                        , ps['thrdproc'], ps['pspcid'], ps['csrss'], ps['session'], ps['deskthrd']
                        , matches if matches > -1 else red('NO VAD'), ps['ExitTime']
                        ))

    def evildlls(self, args=[]):
        argparser = argparse.ArgumentParser(prog=sys._getframe().f_code.co_name
            , description='Find DDLs via ldrmodules which are unlinked somehow (possibly process hollowing)')
        argparser.add_argument('-p', '--pid', type=int, help='Only show DLLs for a specific process PID')
        argparser.add_argument('-v', '--verbose', action='store_true', help='Also show DDLs which are not marked by malfind')

        try:
            opts = argparser.parse_args(args)
        except SystemExit:
            return

        ldrmodules = self._ldrmodules()
        malfind = self._malfind()
        vadinfo = self._vadinfo()

        if not opts.verbose:
            print(red('only showing DLLs marked by malfind'))

        print('%-10s %-20s %5s %-7s %-7s %-7s %-7s %s' % ('Base', 'Process', 'PID', 'InMem', 'InInit', 'InLoad', 'Malfind', 'MappedPath'))

        for mod in ldrmodules:
            if opts.pid and mod['Pid'] != opts.pid:
                continue

            if mod['InLoad'] != 'True' and mod['InInit'] != 'True' and mod['InMem'] != 'True':
                # Locate the memory region of the DLL
                start, end = None, None
                for vad in vadinfo:
                    if mod['Base'] >= vad['Start'] and mod['Base'] <= vad['End']:
                        start = vad['Start']
                        end = vad['End']
                        break

                if not start or not end:
                    print(red('VAD region for PID %d Base 0x%x not found') % (mod['Pid'], mod['Base']))
                    continue

                # Let's see if this region is listed in malfind
                match = False
                for mal in malfind:
                    if mal['Address'] >= start and mal['Address'] <= end:
                        match = True
                        break

                if opts.verbose or match:
                    print('0x%08x %-20s %5s %-7s %-7s %-7s %7s %s' %
                        ( mod['Base'], mod['Process'], mod['Pid'], mod['InMem']
                        , mod['InInit'], mod['InLoad'], red('  MATCH') if match else '-', mod['MappedPath']
                        ))

    def vt(self, args=[]):
        argparser = argparse.ArgumentParser(prog=sys._getframe().f_code.co_name, description='Scan processes, DLLs, injections etc. with VirusTotal')
        argparser.add_argument('-p', '--pid', type=int, required=True, help='PID of process to scan')
        argparser.add_argument('-a', '--addr', type=str, help='Base address')

        try:
            opts = argparser.parse_args(args)
        except SystemExit:
            return

        if 'requests' not in sys.modules:
            print(red('VirusTotal scanning not enabled (requests module is missing).'))
            return

        if opts.addr:
            res = self._exec(['dlldump', '--dump-dir=%s' % self.dumpdir, '--pid=%d' % opts.pid, '--base=%s' % opts.addr], _cache=False)
        else:
            res = self._exec(['procdump', '--dump-dir=%s' % self.dumpdir, '--pid=%d' % opts.pid], _cache=False)

        if not res:
            return

        file = os.path.join(self.dumpdir, res[0]['Result'][4:])

        if not os.path.isfile(file):
            print(red(res[0]['Result']))
            return

        size, unit = human_readable(os.path.getsize(file))
        print('Uploading "%s" (%.1f %s) to VirusTotal' % ((file, size, unit)))

        res = self._vt.scan(file
            , lambda: [sys.stdout.write('Upload finished, waiting for response'), sys.stdout.flush()]
            , lambda: [sys.stdout.write('.'), sys.stdout.flush()]
            )

        if not res:
            return

        print()
        print('Detection rate: %d/%d (%d%%)' % (res['positives'], res['total'], res['positives'] / res['total'] * 100))
        print('Scan date: %s' % res['scan_date'])
        print('URL: %s' % res['permalink'])
        print()

        matches = {}

        for av in res['scans']:
            scan = res['scans'][av]
            if scan['result']:
                if scan['result'] in matches:
                    matches[scan['result']] += 1
                else:
                    matches[scan['result']] = 1

        if len(matches) == 0:
            print(green('No matches'))
        else:
            print('Amount Malware')

            for name, count in sorted(matches.items(), key=operator.itemgetter(1)):
                print('%6d %s' % (count, red(name)))

if __name__ == '__main__':
    default_config_path = os.path.join(os.path.expanduser('~'), '.%s' % __PROG_NAME__, 'config.ini')

    if platform.system() == 'Windows':
        path = win32_get_appdata_path()
        if not path:
            default_config_path = os.path.join(path, __PROG_NAME__, 'config.ini')

    argparser = argparse.ArgumentParser(add_help=False)
    argparser.add_argument('-C', '--config-file', help='Path to the configuration file', default=default_config_path)

    opts, remaining_argv = argparser.parse_known_args(sys.argv[1:])

    defaults = \
        { 'volatility': 'volatility'
        , 'cache':      'cache'
        , 'dump':       'dump'
        , 'vt_workers': 4
        }

    if opts.config_file:
        print('Reading configuration from "%s"' % opts.config_file)

        config = configparser.ConfigParser()
        config.read(opts.config_file)

        if not 'DEFAULT' in config:
            print(red('No [DEFAULT] section in configuration file "%s"' % opts.config_file))
            sys.exit(2)

        defaults.update(config.items('DEFAULT'))

    argparser.set_defaults(**defaults)
    argparser = argparse.ArgumentParser(parents=[argparser], description=__doc__, formatter_class=argparse.ArgumentDefaultsHelpFormatter)

    argparser.add_argument('-v', '--volatility', help='Path to the volatility executable')
    argparser.add_argument('-c', '--cache', help='Path to the caching directory')
    argparser.add_argument('-d', '--dump', help='Path where to drop binary dumps')
    argparser.add_argument('-p', '--profile', help='Image\'s volatility profile')
    argparser.add_argument('-a', '--vt-api-key', help='VirusTotal API key')
    argparser.add_argument('-w', '--vt-workers', help='Amount of VirusTotal workers')
    argparser.add_argument('image', type=str, help='Path to the image to analyze')

    opts = argparser.parse_args(remaining_argv)

    if not os.path.isfile(opts.volatility):
        opts.volatility = which(opts.volatility)

    if not os.path.isfile(opts.volatility):
        print(red('Volatility executable not found: %s' % opts.volatility))
        sys.exit(127)

    mf = MalwareFinder(opts.volatility, opts.cache, opts.dump, opts.image, opts.profile, opts.vt_api_key, opts.vt_workers)

    if not os.path.isdir(opts.cache):
        print('Creating directory "%s"' % opts.cache)
        os.mkdir(opts.cache)

    if not os.path.isdir(opts.dump):
        print('Creating directory "%s"' % opts.dump)
        os.mkdir(opts.dump)

    print('Volatility profile: %s' % mf.profile)
    print('SHA512 checksum: %s' % mf.hash)

    cmds = [m for m in dir(mf) if m[0] != '_' and callable(getattr(mf, m))]

    def completer(text, state):
        options = [cmd for cmd in cmds if cmd.startswith(text)]

        try:
            return options[state]
        except IndexError:
            return None

    if 'readline' in sys.modules:
        HistoryConsole(mf.hash, completer=completer)

    def help():
        print('Internal commands:\n')
        for cmd in cmds:
            print('* :%s' % cmd)
        print('\nEnter ":conf" to show loaded configuration options.')
        print('All other commands are passed to the Volatility executable.')

    print()
    help()
    print()

    while True:
        try:
            cmd, *args = input(blue('%s> ' % os.path.basename(mf.image))).strip().split()
        except ValueError:
            continue
        except KeyboardInterrupt:
            print('\nUse "exit", "quit" or CTRL-D to exit')
            continue
        except EOFError:
            sys.exit(0)

        if cmd in ['quit', ':quit', ':q', 'exit', ':exit', ':e']:
            break
        elif cmd == ':conf':
            for opt in sorted(vars(opts)):
                print('%-11s = %s' % (opt, str(getattr(opts, opt))))
        elif cmd == 'help':
            help()
        elif len(cmd) > 0 and cmd[0] == ':':
            try:
                func = getattr(mf, cmd[1:])
            except AttributeError:
                print('%s: method not found' % cmd[1:])
                continue

            ret = func(args)

            if ret:
                print(json.dumps(ret, indent=4))
        else:
            ret = mf._exec([cmd] + args, False)

            if ret:
                print(ret)
