#!/usr/bin/env python3

import os, atexit, subprocess, threading, queue
import code, sys, argparse, readline
import hashlib, json, re
import time, requests

def red(s): return '\033[91m%s\033[0m' % s
def green(s): return '\033[92m%s\033[0m' % s

class HistoryConsole(code.InteractiveConsole):
    def __init__(self, locals=None, filename='<console>'
            , histfile=os.path.join(os.path.expanduser('~'), '.%s_history' % os.path.splitext(os.path.basename(sys.argv[0]))[0])):
        code.InteractiveConsole.__init__(self, locals, filename)
        self.init_history(histfile)

    def init_history(self, histfile):
        readline.parse_and_bind('tab: complete')
        if hasattr(readline, 'read_history_file'):
            try:
                readline.read_history_file(histfile)
            except FileNotFoundError:
                pass
            atexit.register(self.save_history, histfile)

    def save_history(self, histfile):
        readline.write_history_file(histfile)

class VirusTotal():
    def __init__(self, api_key, nworkers=4):
        self.api_key = api_key
        self.nworkers = nworkers
        self.queue = queue.Queue()
        self.threads = []

    def add(self, file):
        self.queue.put(file, callback)

    def worker(self):
        while True:
            try:
                file, callback = self.queue.get()
            except TypeError:
                return

            callback(file, self.scan(file))

    def stop(self):
        for i in range(self.nworkers):
            self.queue.put(None)

        for t in self.threads:
            t.join()

    def scan(self, file):
        res = requests.post('https://www.virustotal.com/vtapi/v2/file/scan'
            , files={ 'file': ( os.path.basename(file), open(file, 'rb')) }
            , params={ 'apikey': self.api_key }
            ).json()

        resource = res['resource']
        t = 1

        while True:
            res = requests.get('https://www.virustotal.com/vtapi/v2/file/report'
                , params={ 'apikey': self.api_key, 'resource': resource }
                ).json()

            if 'scans' in res:
                break

            time.sleep(t)
            t *= 2

        return res

class MalwareFinder():
    def __init__(self, volatility, cachedir, dumpdir, image, profile, vt_api_key, vt_workers):
        self.volatility = volatility
        self.cachedir = cachedir
        self.dumpdir = dumpdir
        self.image = image
        self.profile = profile
        self._vt = VirusTotal(vt_api_key, vt_workers)

        if os.path.isfile(self.image + '.sha512sum'):
            self.hash = open(self.image + '.sha512sum', 'r').read().split()[0]
        else:
            print('Generating SHA512 checksum of "%s"' % self.image)
            h = hashlib.sha512()

            with open(self.image, 'rb') as f:
                for chunk in iter(lambda: f.read(65536), b''):
                    h.update(chunk)

            self.hash = h.hexdigest()
            open(self.image + '.sha512sum', 'w').write('%s  %s\n' % (self.hash, os.path.basename(self.image)))

    def _cache(self, name, data=None):
        path = os.path.join(self.cachedir, '%s.cache' % name)

        if data:
            open(path, 'w').write(data)
            return data
        else:
            if os.path.isfile(path):
                return open(path, 'r', encoding='utf-8').read()
            else:
                return None

    def _exec(self, args, _json=True, _cache=True, showexec=True):
        cmd = [ self.volatility, '--filename=' + os.path.abspath(self.image) ]

        if _json:
              cmd.append('--output=json')

        if self.profile:
            cmd.append('--profile=' + self.profile)

        cmd.extend(args)

        if _cache:
            hash = hashlib.sha512(('%s_%s_%s_%s' % (self.hash, 'json' if _json else 'console', self.profile, ' '.join(args))).encode('utf-8')).hexdigest()
            cache = self._cache(hash)
        else:
            cache = None

        if not cache:
            if showexec:
                print('Executing "%s"' % ' '.join(args))

            p = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            stdout, stderr = p.communicate()

            if p.returncode != 0:
                print(stderr)
                return None

            cache = self._cache(hash, stdout.decode('utf-8')) if _cache else stdout.decode('utf-8')

        if _json:
            data = json.loads(cache)
            norm = []

            for row in data['rows']:
                norm.append(dict(zip(data['columns'], row)))

            return norm
        else:
            return cache

    def identify(self, _=None):
        if not self.profile:
            data = self.imageinfo()
            profiles = re.split('[, ]+', re.sub('\s*\([^)]*\)\s*', '', data[0]['Suggested Profile(s)']))

            for profile in profiles:
                print('Testing profile "%s"' % profile)
                self.profile = profile
                if self._exec(['pslist'], showexec=False):
                    break

        return self.profile

    def printkey_autostart(self, _=None):
        return self._exec(['printkey', '-K', 'Software\\Microsoft\\Windows\\CurrentVersion\\Run'])

    def imageinfo(self, _=None):
        return self._exec(['imageinfo'])

    def pslist(self, _=None):
        return self._exec(['pslist'])

    def dlllist(self, _=None):
        return self._exec(['dlllist'])

    def evildll(self, _=None):
        for dll in self.dlllist():
            if not dll['Path'] in ['Error reading PEB for pid', ''] and not re.match('^[Cc]:\\\\(Program Files|[Ww]indows|WINDOWS)\\\\', dll['Path']):
                print(json.dumps(dll, indent=4))

    def psxview(self, _=None):
        return self._exec(['psxview', '--apply-rules'])

    def evilps(self, _=None):
        for ps in self.psxview():
            for key in ['thrdproc', 'csrss', 'pslist', 'deskthrd', 'session', 'pspcid', 'psscan']:
                if not ps[key] in ['True', 'Okay']:
                    print(json.dumps(ps, indent=4))
                    break

    def ldrmodules(self, _=None):
        return self._exec(['ldrmodules'])

    def malfind(self, _=None):
        return self._exec(['malfind'])

    def vadinfo(self, _=None):
        return self._exec(['vadinfo'])

    def apihooks(self, _=None):
        return self._exec(['apihooks'])

    def correlate(self, _=None):
        malfind = self.malfind()
        vadinfo = self.vadinfo()
        apihooks = self.apihooks()

        pids = []

        for mal in malfind:
            for vad in vadinfo:
                if mal['Address'] >= vad['Start'] and mal['Address'] <= vad['End']:
                    start = vad['Start']
                    end = vad['End']
                    break

            for hook in apihooks:
                if hook['HookAddress'] >= start and hook['HookAddress'] <= end:

                    if mal['Pid'] in pids:
                        break

                    pids.append(mal['Pid'])

                    print('cmd: %s\npid: %d' % (mal['Process'], mal['Pid']))
                    print(json.dumps(hook, indent=4))
                    break

    def hollow(self, _=None):
        malfind = self.malfind()

        for mal in malfind:
            ldrmodules = self._exec(['ldrmodules', '-p', str(mal['Pid'])])

            for mod in ldrmodules:
                if mod['InLoad'] != 'True' and mod['InInit'] != 'True' and mod['InMem'] != 'True':
                    print(json.dumps(mod, indent=4))
                    break

    def strings(self):
        pass # TODO

    def vt(self, args):
        argparser = argparse.ArgumentParser(prog=sys._getframe().f_code.co_name, description='Scan processes, DLLs, injections etc. with VirusTotal')
        argparser.add_argument('-p', '--pid', type=int, required=True, help='PID of process to scan')

        try:
            opts = argparser.parse_args(args)
        except SystemExit:
            return

        res = self._exec(['procdump', '--dump-dir=%s' % self.dumpdir, '--pid=%d' % opts.pid], _cache=False)
        file = os.path.join(self.dumpdir, res[0]['Result'][4:])

        if not os.path.isfile(file):
            print(json.dumps(res[0], indent=4))
            return

        print('Uploading "%s" to VirusTotal' % file)
        res = self._vt.scan(file)

        print('Detection rate: %d/%d (%d%%)' % (res['positives'], res['total'], res['positives'] / res['total'] * 100))
        print('Scan date: %s' % res['scan_date'])
        print('URL: %s' % res['permalink'])
        print()

        matches = {}

        for av in res['scans']:
            scan = res['scans'][av]
            if scan['result']:
                if scan['result'] in matches:
                    matches[scan['result']] += 1
                else:
                    matches[scan['result']] = 1

        if len(matches) == 0:
            print(green('No matches'))
        else:
            print('Amount Malware')

            for name, count in matches.items():
                print('%6d %s' % (count, red(name)))

if __name__ == '__main__':
    argparser = argparse.ArgumentParser()
    argparser.add_argument('-v', '--volatility', default='/home/y/bfh/malware/volatility_2.5.linux.standalone/volatility_2.5_linux_x64',
        help='Path to the volatility executable')
    argparser.add_argument('-c', '--cache', default='cache', help='Path to the caching directory')
    argparser.add_argument('-d', '--dump', default='dump', help='Path where to drop binary dumps')
    argparser.add_argument('-p', '--profile', default=None, help='Image\'s volatility profile')
    argparser.add_argument('-a', '--vt-api-key', default='b8901cc6edbe0d73f46bcaa2ecc0dc38c7ae26daccbb5f7aecc9fdfb4378acce', help='VirusTotal API key')
    argparser.add_argument('-w', '--vt-workers', default=4, help='Amount of VirusTotal workers')
    argparser.add_argument('image', type=str, help='Path to the image to analyze')

    options = argparser.parse_args(sys.argv[1:])
    mf = MalwareFinder(options.volatility, options.cache, options.dump, options.image, options.profile, options.vt_api_key, options.vt_workers)

    if not os.path.isdir(options.cache):
        print('Creating directory "%s"' % options.cache)
        os.mkdir(options.cache)

    if not os.path.isdir(options.dump):
        print('Creating directory "%s"' % options.dump)
        os.mkdir(options.dump)

    print('SHA512 checksum: %s' % mf.hash)
    print('Profile: %s' % mf.identify())

    while True:
        try:
            cmd, *args = input(os.path.splitext(os.path.basename(sys.argv[0]))[0] + '> ').strip().split()
        except ValueError:
            continue

        if cmd == 'quit':
            break
        elif cmd == 'help':
            print('Internal commands:')
            for m in [m for m in dir(mf) if m[0] != '_' and callable(getattr(mf, m))]:
                print('* %s' % m)
        elif len(cmd) > 0 and cmd[0] == ':':
            func = getattr(mf, cmd[1:])

            if func:
                #try:
                ret = func(args)
                #except Exception as err:
                #    print('Unexpected error: %s' % err)
                #    continue

                if ret:
                    print(json.dumps(ret, indent=4))
            else:
                print('%s: method not found' % cmd[1:])
        else:
            print(mf._exec([cmd] + args, False))
